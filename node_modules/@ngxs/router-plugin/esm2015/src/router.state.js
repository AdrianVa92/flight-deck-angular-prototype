import * as tslib_1 from "tslib";
var RouterState_1;
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NgZone, Injectable } from '@angular/core';
import { NavigationCancel, NavigationError, Router, RouterStateSnapshot, RoutesRecognized, ResolveEnd, UrlSerializer, NavigationStart, NavigationEnd, GuardsCheckEnd } from '@angular/router';
import { LocationStrategy, Location } from '@angular/common';
import { Action, Selector, State, StateContext, Store } from '@ngxs/store';
import { isAngularInTestMode } from '@ngxs/store/internals';
import { first } from 'rxjs/operators';
import { Navigate, RouterCancel, RouterError, RouterNavigation, RouterDataResolved } from './router.actions';
import { RouterStateSerializer } from './serializer';
/**
 * @record
 * @template T
 */
export function RouterStateModel() { }
if (false) {
    /** @type {?|undefined} */
    RouterStateModel.prototype.state;
    /** @type {?|undefined} */
    RouterStateModel.prototype.navigationId;
    /** @type {?} */
    RouterStateModel.prototype.trigger;
}
let RouterState = RouterState_1 = class RouterState {
    /**
     * @param {?} _store
     * @param {?} _router
     * @param {?} _serializer
     * @param {?} _ngZone
     * @param {?} _urlSerializer
     * @param {?} _locationStrategy
     * @param {?} _location
     */
    constructor(_store, _router, _serializer, _ngZone, _urlSerializer, _locationStrategy, _location) {
        this._store = _store;
        this._router = _router;
        this._serializer = _serializer;
        this._ngZone = _ngZone;
        this._urlSerializer = _urlSerializer;
        this._locationStrategy = _locationStrategy;
        this._location = _location;
        /**
         * Determines how navigation was performed by the `RouterState` itself
         * or outside via `new Navigate(...)`
         */
        this._trigger = 'none';
        /**
         * That's the serialized state from the `Router` class
         */
        this._routerState = null;
        /**
         * That's the value of the `RouterState` state
         */
        this._storeState = null;
        this._lastRoutesRecognized = (/** @type {?} */ (null));
        this.setUpStoreListener();
        this.setUpRouterEventsListener();
        this.checkInitialNavigationOnce();
    }
    /**
     * @template T
     * @param {?} state
     * @return {?}
     */
    static state(state) {
        return state && state.state;
    }
    /**
     * @param {?} state
     * @return {?}
     */
    static url(state) {
        return state && state.state && state.state.url;
    }
    /**
     * @param {?} _
     * @param {?} action
     * @return {?}
     */
    navigate(_, action) {
        return this._ngZone.run((/**
         * @return {?}
         */
        () => this._router.navigate(action.path, Object.assign({ queryParams: action.queryParams }, action.extras))));
    }
    /**
     * @param {?} ctx
     * @param {?} action
     * @return {?}
     */
    angularRouterAction(ctx, action) {
        ctx.setState(Object.assign({}, ctx.getState(), { trigger: action.trigger, state: action.routerState, navigationId: action.event.id }));
    }
    /**
     * @private
     * @return {?}
     */
    setUpStoreListener() {
        this._store.select(RouterState_1).subscribe((/**
         * @param {?} state
         * @return {?}
         */
        (state) => {
            this.navigateIfNeeded(state);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    setUpRouterEventsListener() {
        this._router.events.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (event instanceof NavigationStart) {
                this.navigationStart();
            }
            else if (event instanceof RoutesRecognized) {
                this._lastRoutesRecognized = event;
            }
            else if (event instanceof GuardsCheckEnd && event.shouldActivate) {
                this.guardsCheckEnd(event);
            }
            else if (event instanceof ResolveEnd) {
                this.dispatchRouterDataResolved(event);
            }
            else if (event instanceof NavigationCancel) {
                this.dispatchRouterCancel(event);
                this.reset();
            }
            else if (event instanceof NavigationError) {
                this.dispatchRouterError(event);
                this.reset();
            }
            else if (event instanceof NavigationEnd) {
                this.reset();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    navigationStart() {
        this._routerState = this._serializer.serialize(this._router.routerState.snapshot);
        if (this._trigger !== 'none') {
            this._storeState = this._store.selectSnapshot(RouterState_1);
        }
    }
    /**
     * @private
     * @return {?}
     */
    shouldDispatchRouterNavigation() {
        if (!this._storeState)
            return true;
        return this._trigger !== 'store';
    }
    /**
     * @private
     * @param {?} state
     * @return {?}
     */
    navigateIfNeeded(state) {
        /** @type {?} */
        const canSkipNavigation = !this._storeState ||
            !this._storeState.state ||
            !state ||
            state.trigger === 'router' ||
            this._router.url === this._storeState.state.url;
        if (canSkipNavigation) {
            return;
        }
        this._trigger = 'store';
        this._ngZone.run((/**
         * @return {?}
         */
        () => {
            this._router.navigateByUrl((/** @type {?} */ ((/** @type {?} */ (this._storeState)).state)).url);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    dispatchRouterNavigation() {
        /** @type {?} */
        const nextRouterState = this._serializer.serialize(this._lastRoutesRecognized.state);
        this.dispatchRouterAction(new RouterNavigation(nextRouterState, new RoutesRecognized(this._lastRoutesRecognized.id, this._lastRoutesRecognized.url, this._lastRoutesRecognized.urlAfterRedirects, nextRouterState), this._trigger));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dispatchRouterCancel(event) {
        this.dispatchRouterAction(new RouterCancel((/** @type {?} */ (this._routerState)), this._storeState, event, this._trigger));
        this.reset();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dispatchRouterError(event) {
        this.dispatchRouterAction(new RouterError((/** @type {?} */ (this._routerState)), this._storeState, new NavigationError(event.id, event.url, `${event}`), this._trigger));
    }
    /**
     * @private
     * @template T
     * @param {?} action
     * @return {?}
     */
    dispatchRouterAction(action) {
        this._trigger = 'router';
        try {
            this._store.dispatch(action);
        }
        finally {
            this._trigger = 'none';
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    guardsCheckEnd(event) {
        this._routerState = this._serializer.serialize(event.state);
        if (this.shouldDispatchRouterNavigation()) {
            this.dispatchRouterNavigation();
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dispatchRouterDataResolved(event) {
        /** @type {?} */
        const routerState = this._serializer.serialize(event.state);
        this.dispatchRouterAction(new RouterDataResolved(routerState, event, this._trigger));
    }
    /**
     * @private
     * @return {?}
     */
    reset() {
        this._trigger = 'none';
        this._storeState = null;
        this._routerState = null;
    }
    /**
     * No sense to mess up the `setUpRouterEventsListener` method as we have
     * to perform this check only once and unsubscribe after the first event
     * is triggered
     * @private
     * @return {?}
     */
    checkInitialNavigationOnce() {
        if (isAngularInTestMode()) {
            return;
        }
        this._router.events
            .pipe(first((/**
         * @param {?} event
         * @return {?}
         */
        (event) => event instanceof RoutesRecognized)))
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ({ url }) => {
            // `location.pathname` always equals manually entered URL in the address bar
            // e.g. `location.pathname === '/foo'`, but the `router` state has been initialized
            // with another URL (e.g. used in combination with `NgxsStoragePlugin`), thus the
            // `RouterNavigation` action will be dispatched and the user will be redirected to the
            // previously saved URL. We want to prevent such behavior, so we perform this check
            // `location.pathname` always equals manually entered URL in the address bar
            // e.g. `location.pathname === '/foo'`, but the `router` state has been initialized
            // with another URL (e.g. used in combination with `NgxsStoragePlugin`), thus the
            // `RouterNavigation` action will be dispatched and the user will be redirected to the
            // previously saved URL. We want to prevent such behavior, so we perform this check
            // `url` is a recognized URL by the Angular's router, while `currentUrl` is an actual URL
            // entered in the browser's address bar
            // `PathLocationStrategy.prototype.path()` returns a concatenation of
            // `PlatformLocation.pathname` and normalized `PlatformLocation.search`.
            // `Location.prototype.normalize` strips base href from the URL,
            // if `baseHref` (declared in angular.json) for example is `/en`
            // and the URL is `/test#anchor` - then `_locationStrategy.path(true)` will return `/en/test#anchor`,
            // but `/en/test#anchor` is not known to the Angular's router, so we have to strip `/en`
            // from the URL
            /** @type {?} */
            const currentUrl = this._location.normalize(this._locationStrategy.path(true));
            /** @type {?} */
            const currentUrlTree = this._urlSerializer.parse(currentUrl);
            // We need to serialize the URL because in that example `/test/?redirect=https://google.com/`
            // Angular will recognize it as `/test?redirect=https:%2F%2Fwww.google.com%2F`
            // so we have to run the `currentUrl` via the `UrlSerializer` that will encode characters
            /** @type {?} */
            const currentSerializedUrl = this._urlSerializer.serialize(currentUrlTree);
            // If URLs differ from each other - we've got to perform a redirect to the manually entered URL
            // in the address bar, as it must have a priority
            if (currentSerializedUrl !== url) {
                this._router.navigateByUrl(currentUrl);
            }
        }));
    }
};
RouterState.ctorParameters = () => [
    { type: Store },
    { type: Router },
    { type: RouterStateSerializer },
    { type: NgZone },
    { type: UrlSerializer },
    { type: LocationStrategy },
    { type: Location }
];
RouterState.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RouterState.ctorParameters = () => [
    { type: Store },
    { type: Router },
    { type: RouterStateSerializer },
    { type: NgZone },
    { type: UrlSerializer },
    { type: LocationStrategy },
    { type: Location }
];
tslib_1.__decorate([
    Action(Navigate),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Navigate]),
    tslib_1.__metadata("design:returntype", void 0)
], RouterState.prototype, "navigate", null);
tslib_1.__decorate([
    Action([RouterNavigation, RouterError, RouterCancel, RouterDataResolved]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
], RouterState.prototype, "angularRouterAction", null);
tslib_1.__decorate([
    Selector(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], RouterState, "state", null);
tslib_1.__decorate([
    Selector(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Object)
], RouterState, "url", null);
RouterState = RouterState_1 = tslib_1.__decorate([
    State({
        name: 'router',
        defaults: {
            state: undefined,
            navigationId: undefined,
            trigger: 'none'
        }
    }),
    tslib_1.__metadata("design:paramtypes", [Store,
        Router,
        RouterStateSerializer,
        NgZone,
        UrlSerializer,
        LocationStrategy,
        Location])
], RouterState);
export { RouterState };
if (false) {
    /**
     * Determines how navigation was performed by the `RouterState` itself
     * or outside via `new Navigate(...)`
     * @type {?}
     * @private
     */
    RouterState.prototype._trigger;
    /**
     * That's the serialized state from the `Router` class
     * @type {?}
     * @private
     */
    RouterState.prototype._routerState;
    /**
     * That's the value of the `RouterState` state
     * @type {?}
     * @private
     */
    RouterState.prototype._storeState;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._lastRoutesRecognized;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._store;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._router;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._serializer;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._urlSerializer;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._locationStrategy;
    /**
     * @type {?}
     * @private
     */
    RouterState.prototype._location;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyLnN0YXRlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvcm91dGVyLXBsdWdpbi8iLCJzb3VyY2VzIjpbInNyYy9yb3V0ZXIuc3RhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixlQUFlLEVBQ2YsTUFBTSxFQUNOLG1CQUFtQixFQUNuQixnQkFBZ0IsRUFDaEIsVUFBVSxFQUNWLGFBQWEsRUFDYixlQUFlLEVBQ2YsYUFBYSxFQUNiLGNBQWMsRUFDZixNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUMzRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdkMsT0FBTyxFQUNMLFFBQVEsRUFFUixZQUFZLEVBQ1osV0FBVyxFQUNYLGdCQUFnQixFQUNoQixrQkFBa0IsRUFDbkIsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxjQUFjLENBQUM7Ozs7O0FBRXJELHNDQUlDOzs7SUFIQyxpQ0FBVTs7SUFDVix3Q0FBc0I7O0lBQ3RCLG1DQUF1Qjs7SUFjWixXQUFXLHlCQUFYLFdBQVc7Ozs7Ozs7Ozs7SUE2QnRCLFlBQ1UsTUFBYSxFQUNiLE9BQWUsRUFDZixXQUF1RCxFQUN2RCxPQUFlLEVBQ2YsY0FBNkIsRUFDN0IsaUJBQW1DLEVBQ25DLFNBQW1CO1FBTm5CLFdBQU0sR0FBTixNQUFNLENBQU87UUFDYixZQUFPLEdB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LFNBQVM7WUFDaEIsWUFBWSxFQUFFLFNBQVM7WUFDdkIsT0FBTyxFQUFFLE1BQU07U0FDaEI7S0FDRixDQUFDOzZDQWdDa0IsS0FBSztRQUNKLE1BQU07UUFDRixxQkFBcUI7UUFDekIsTUFBTTtRQUNDLGFBQWE7UUFDVixnQkFBZ0I7UUFDeEIsUUFBUTtHQXBDbEIsV0FBVyxDQXdPdkI7U0F4T1ksV0FBVzs7Ozs7Ozs7SUFLdEIsK0JBQXlDOzs7Ozs7SUFLekMsbUNBQXdEOzs7Ozs7SUFLeEQsa0NBQW9EOzs7OztJQUVwRCw0Q0FBd0Q7Ozs7O0lBYXRELDZCQUFxQjs7Ozs7SUFDckIsOEJBQXVCOzs7OztJQUN2QixrQ0FBK0Q7Ozs7O0lBQy9ELDhCQUF1Qjs7Ozs7SUFDdkIscUNBQXFDOzs7OztJQUNyQyx3Q0FBMkM7Ozs7O0lBQzNDLGdDQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nWm9uZSwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIE5hdmlnYXRpb25DYW5jZWwsXHJcbiAgTmF2aWdhdGlvbkVycm9yLFxyXG4gIFJvdXRlcixcclxuICBSb3V0ZXJTdGF0ZVNuYXBzaG90LFxyXG4gIFJvdXRlc1JlY29nbml6ZWQsXHJcbiAgUmVzb2x2ZUVuZCxcclxuICBVcmxTZXJpYWxpemVyLFxyXG4gIE5hdmlnYXRpb25TdGFydCxcclxuICBOYXZpZ2F0aW9uRW5kLFxyXG4gIEd1YXJkc0NoZWNrRW5kXHJcbn0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgTG9jYXRpb25TdHJhdGVneSwgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBBY3Rpb24sIFNlbGVjdG9yLCBTdGF0ZSwgU3RhdGVDb250ZXh0LCBTdG9yZSB9IGZyb20gJ0BuZ3hzL3N0b3JlJztcclxuaW1wb3J0IHsgaXNBbmd1bGFySW5UZXN0TW9kZSB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XHJcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBOYXZpZ2F0ZSxcclxuICBSb3V0ZXJBY3Rpb24sXHJcbiAgUm91dGVyQ2FuY2VsLFxyXG4gIFJvdXRlckVycm9yLFxyXG4gIFJvdXRlck5hdmlnYXRpb24sXHJcbiAgUm91dGVyRGF0YVJlc29sdmVkXHJcbn0gZnJvbSAnLi9yb3V0ZXIuYWN0aW9ucyc7XHJcbmltcG9ydCB7IFJvdXRlclN0YXRlU2VyaWFsaXplciB9IGZyb20gJy4vc2VyaWFsaXplcic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN0YXRlTW9kZWw8VCA9IFJvdXRlclN0YXRlU25hcHNob3Q+IHtcclxuICBzdGF0ZT86IFQ7XHJcbiAgbmF2aWdhdGlvbklkPzogbnVtYmVyO1xyXG4gIHRyaWdnZXI6IFJvdXRlclRyaWdnZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFJvdXRlclRyaWdnZXIgPSAnbm9uZScgfCAncm91dGVyJyB8ICdzdG9yZSc7XHJcblxyXG5AU3RhdGU8Um91dGVyU3RhdGVNb2RlbD4oe1xyXG4gIG5hbWU6ICdyb3V0ZXInLFxyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBzdGF0ZTogdW5kZWZpbmVkLFxyXG4gICAgbmF2aWdhdGlvbklkOiB1bmRlZmluZWQsXHJcbiAgICB0cmlnZ2VyOiAnbm9uZSdcclxuICB9XHJcbn0pXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFJvdXRlclN0YXRlIHtcclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGhvdyBuYXZpZ2F0aW9uIHdhcyBwZXJmb3JtZWQgYnkgdGhlIGBSb3V0ZXJTdGF0ZWAgaXRzZWxmXHJcbiAgICogb3Igb3V0c2lkZSB2aWEgYG5ldyBOYXZpZ2F0ZSguLi4pYFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3RyaWdnZXI6IFJvdXRlclRyaWdnZXIgPSAnbm9uZSc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoYXQncyB0aGUgc2VyaWFsaXplZCBzdGF0ZSBmcm9tIHRoZSBgUm91dGVyYCBjbGFzc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgX3JvdXRlclN0YXRlOiBSb3V0ZXJTdGF0ZVNuYXBzaG90IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoYXQncyB0aGUgdmFsdWUgb2YgdGhlIGBSb3V0ZXJTdGF0ZWAgc3RhdGVcclxuICAgKi9cclxuICBwcml2YXRlIF9zdG9yZVN0YXRlOiBSb3V0ZXJTdGF0ZU1vZGVsIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgX2xhc3RSb3V0ZXNSZWNvZ25pemVkOiBSb3V0ZXNSZWNvZ25pemVkID0gbnVsbCE7XHJcblxyXG4gIEBTZWxlY3RvcigpXHJcbiAgc3RhdGljIHN0YXRlPFQgPSBSb3V0ZXJTdGF0ZVNuYXBzaG90PihzdGF0ZTogUm91dGVyU3RhdGVNb2RlbDxUPikge1xyXG4gICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnN0YXRlO1xyXG4gIH1cclxuXHJcbiAgQFNlbGVjdG9yKClcclxuICBzdGF0aWMgdXJsKHN0YXRlOiBSb3V0ZXJTdGF0ZU1vZGVsKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5zdGF0ZSAmJiBzdGF0ZS5zdGF0ZS51cmw7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX3N0b3JlOiBTdG9yZSxcclxuICAgIHByaXZhdGUgX3JvdXRlcjogUm91dGVyLFxyXG4gICAgcHJpdmF0ZSBfc2VyaWFsaXplcjogUm91dGVyU3RhdGVTZXJpYWxpemVyPFJvdXRlclN0YXRlU25hcHNob3Q+LFxyXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXHJcbiAgICBwcml2YXRlIF91cmxTZXJpYWxpemVyOiBVcmxTZXJpYWxpemVyLFxyXG4gICAgcHJpdmF0ZSBfbG9jYXRpb25TdHJhdGVneTogTG9jYXRpb25TdHJhdGVneSxcclxuICAgIHByaXZhdGUgX2xvY2F0aW9uOiBMb2NhdGlvblxyXG4gICkge1xyXG4gICAgdGhpcy5zZXRVcFN0b3JlTGlzdGVuZXIoKTtcclxuICAgIHRoaXMuc2V0VXBSb3V0ZXJFdmVudHNMaXN0ZW5lcigpO1xyXG4gICAgdGhpcy5jaGVja0luaXRpYWxOYXZpZ2F0aW9uT25jZSgpO1xyXG4gIH1cclxuXHJcbiAgQEFjdGlvbihOYXZpZ2F0ZSlcclxuICBuYXZpZ2F0ZShfOiBTdGF0ZUNvbnRleHQ8Um91dGVyU3RhdGVNb2RlbD4sIGFjdGlvbjogTmF2aWdhdGUpIHtcclxuICAgIHJldHVybiB0aGlzLl9uZ1pvbmUucnVuKCgpID0+XHJcbiAgICAgIHRoaXMuX3JvdXRlci5uYXZpZ2F0ZShhY3Rpb24ucGF0aCwge1xyXG4gICAgICAgIHF1ZXJ5UGFyYW1zOiBhY3Rpb24ucXVlcnlQYXJhbXMsXHJcbiAgICAgICAgLi4uYWN0aW9uLmV4dHJhc1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIEBBY3Rpb24oW1JvdXRlck5hdmlnYXRpb24sIFJvdXRlckVycm9yLCBSb3V0ZXJDYW5jZWwsIFJvdXRlckRhdGFSZXNvbHZlZF0pXHJcbiAgYW5ndWxhclJvdXRlckFjdGlvbihcclxuICAgIGN0eDogU3RhdGVDb250ZXh0PFJvdXRlclN0YXRlTW9kZWw+LFxyXG4gICAgYWN0aW9uOiBSb3V0ZXJBY3Rpb248Um91dGVyU3RhdGVNb2RlbCwgUm91dGVyU3RhdGVTbmFwc2hvdD5cclxuICApOiB2b2lkIHtcclxuICAgIGN0eC5zZXRTdGF0ZSh7XHJcbiAgICAgIC4uLmN0eC5nZXRTdGF0ZSgpLFxyXG4gICAgICB0cmlnZ2VyOiBhY3Rpb24udHJpZ2dlcixcclxuICAgICAgc3RhdGU6IGFjdGlvbi5yb3V0ZXJTdGF0ZSxcclxuICAgICAgbmF2aWdhdGlvbklkOiBhY3Rpb24uZXZlbnQuaWRcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzZXRVcFN0b3JlTGlzdGVuZXIoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9zdG9yZS5zZWxlY3QoUm91dGVyU3RhdGUpLnN1YnNjcmliZSgoc3RhdGU6IFJvdXRlclN0YXRlTW9kZWwgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgdGhpcy5uYXZpZ2F0ZUlmTmVlZGVkKHN0YXRlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzZXRVcFJvdXRlckV2ZW50c0xpc3RlbmVyKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZXZlbnQgPT4ge1xyXG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uU3RhcnQpIHtcclxuICAgICAgICB0aGlzLm5hdmlnYXRpb25TdGFydCgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgUm91dGVzUmVjb2duaXplZCkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RSb3V0ZXNSZWNvZ25pemVkID0gZXZlbnQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBHdWFyZHNDaGVja0VuZCAmJiBldmVudC5zaG91bGRBY3RpdmF0ZSkge1xyXG4gICAgICAgIHRoaXMuZ3VhcmRzQ2hlY2tFbmQoZXZlbnQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgUmVzb2x2ZUVuZCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSb3V0ZXJEYXRhUmVzb2x2ZWQoZXZlbnQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkNhbmNlbCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSb3V0ZXJDYW5jZWwoZXZlbnQpO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgfSBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FcnJvcikge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSb3V0ZXJFcnJvcihldmVudCk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG5hdmlnYXRpb25TdGFydCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3JvdXRlclN0YXRlID0gdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5fcm91dGVyLnJvdXRlclN0YXRlLnNuYXBzaG90KTtcclxuXHJcbiAgICBpZiAodGhpcy5fdHJpZ2dlciAhPT0gJ25vbmUnKSB7XHJcbiAgICAgIHRoaXMuX3N0b3JlU3RhdGUgPSB0aGlzLl9zdG9yZS5zZWxlY3RTbmFwc2hvdChSb3V0ZXJTdGF0ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNob3VsZERpc3BhdGNoUm91dGVyTmF2aWdhdGlvbigpOiBib29sZWFuIHtcclxuICAgIGlmICghdGhpcy5fc3RvcmVTdGF0ZSkgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gdGhpcy5fdHJpZ2dlciAhPT0gJ3N0b3JlJztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbmF2aWdhdGVJZk5lZWRlZChzdGF0ZTogUm91dGVyU3RhdGVNb2RlbCB8IHVuZGVmaW5lZCk6IHZvaWQge1xyXG4gICAgY29uc3QgY2FuU2tpcE5hdmlnYXRpb24gPVxyXG4gICAgICAhdGhpcy5fc3RvcmVTdGF0ZSB8fFxyXG4gICAgICAhdGhpcy5fc3RvcmVTdGF0ZS5zdGF0ZSB8fFxyXG4gICAgICAhc3RhdGUgfHxcclxuICAgICAgc3RhdGUudHJpZ2dlciA9PT0gJ3JvdXRlcicgfHxcclxuICAgICAgdGhpcy5fcm91dGVyLnVybCA9PT0gdGhpcy5fc3RvcmVTdGF0ZS5zdGF0ZS51cmw7XHJcblxyXG4gICAgaWYgKGNhblNraXBOYXZpZ2F0aW9uKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl90cmlnZ2VyID0gJ3N0b3JlJztcclxuICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGVCeVVybCh0aGlzLl9zdG9yZVN0YXRlIS5zdGF0ZSEudXJsKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFJvdXRlck5hdmlnYXRpb24oKTogdm9pZCB7XHJcbiAgICBjb25zdCBuZXh0Um91dGVyU3RhdGUgPSB0aGlzLl9zZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLl9sYXN0Um91dGVzUmVjb2duaXplZC5zdGF0ZSk7XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaFJvdXRlckFjdGlvbihcclxuICAgICAgbmV3IFJvdXRlck5hdmlnYXRpb24oXHJcbiAgICAgICAgbmV4dFJvdXRlclN0YXRlLFxyXG4gICAgICAgIG5ldyBSb3V0ZXNSZWNvZ25pemVkKFxyXG4gICAgICAgICAgdGhpcy5fbGFzdFJvdXRlc1JlY29nbml6ZWQuaWQsXHJcbiAgICAgICAgICB0aGlzLl9sYXN0Um91dGVzUmVjb2duaXplZC51cmwsXHJcbiAgICAgICAgICB0aGlzLl9sYXN0Um91dGVzUmVjb2duaXplZC51cmxBZnRlclJlZGlyZWN0cyxcclxuICAgICAgICAgIG5leHRSb3V0ZXJTdGF0ZVxyXG4gICAgICAgICksXHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlclxyXG4gICAgICApXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFJvdXRlckNhbmNlbChldmVudDogTmF2aWdhdGlvbkNhbmNlbCk6IHZvaWQge1xyXG4gICAgdGhpcy5kaXNwYXRjaFJvdXRlckFjdGlvbihcclxuICAgICAgbmV3IFJvdXRlckNhbmNlbCh0aGlzLl9yb3V0ZXJTdGF0ZSEsIHRoaXMuX3N0b3JlU3RhdGUsIGV2ZW50LCB0aGlzLl90cmlnZ2VyKVxyXG4gICAgKTtcclxuICAgIHRoaXMucmVzZXQoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGlzcGF0Y2hSb3V0ZXJFcnJvcihldmVudDogTmF2aWdhdGlvbkVycm9yKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc3BhdGNoUm91dGVyQWN0aW9uKFxyXG4gICAgICBuZXcgUm91dGVyRXJyb3IoXHJcbiAgICAgICAgdGhpcy5fcm91dGVyU3RhdGUhLFxyXG4gICAgICAgIHRoaXMuX3N0b3JlU3RhdGUsXHJcbiAgICAgICAgbmV3IE5hdmlnYXRpb25FcnJvcihldmVudC5pZCwgZXZlbnQudXJsLCBgJHtldmVudH1gKSxcclxuICAgICAgICB0aGlzLl90cmlnZ2VyXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRpc3BhdGNoUm91dGVyQWN0aW9uPFQ+KGFjdGlvbjogUm91dGVyQWN0aW9uPFQ+KTogdm9pZCB7XHJcbiAgICB0aGlzLl90cmlnZ2VyID0gJ3JvdXRlcic7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMuX3RyaWdnZXIgPSAnbm9uZSc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGd1YXJkc0NoZWNrRW5kKGV2ZW50OiBHdWFyZHNDaGVja0VuZCkge1xyXG4gICAgdGhpcy5fcm91dGVyU3RhdGUgPSB0aGlzLl9zZXJpYWxpemVyLnNlcmlhbGl6ZShldmVudC5zdGF0ZSk7XHJcblxyXG4gICAgaWYgKHRoaXMuc2hvdWxkRGlzcGF0Y2hSb3V0ZXJOYXZpZ2F0aW9uKCkpIHtcclxuICAgICAgdGhpcy5kaXNwYXRjaFJvdXRlck5hdmlnYXRpb24oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGlzcGF0Y2hSb3V0ZXJEYXRhUmVzb2x2ZWQoZXZlbnQ6IFJlc29sdmVFbmQpOiB2b2lkIHtcclxuICAgIGNvbnN0IHJvdXRlclN0YXRlID0gdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemUoZXZlbnQuc3RhdGUpO1xyXG4gICAgdGhpcy5kaXNwYXRjaFJvdXRlckFjdGlvbihuZXcgUm91dGVyRGF0YVJlc29sdmVkKHJvdXRlclN0YXRlLCBldmVudCwgdGhpcy5fdHJpZ2dlcikpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZXNldCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3RyaWdnZXIgPSAnbm9uZSc7XHJcbiAgICB0aGlzLl9zdG9yZVN0YXRlID0gbnVsbDtcclxuICAgIHRoaXMuX3JvdXRlclN0YXRlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vIHNlbnNlIHRvIG1lc3MgdXAgdGhlIGBzZXRVcFJvdXRlckV2ZW50c0xpc3RlbmVyYCBtZXRob2QgYXMgd2UgaGF2ZVxyXG4gICAqIHRvIHBlcmZvcm0gdGhpcyBjaGVjayBvbmx5IG9uY2UgYW5kIHVuc3Vic2NyaWJlIGFmdGVyIHRoZSBmaXJzdCBldmVudFxyXG4gICAqIGlzIHRyaWdnZXJlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2hlY2tJbml0aWFsTmF2aWdhdGlvbk9uY2UoKTogdm9pZCB7XHJcbiAgICBpZiAoaXNBbmd1bGFySW5UZXN0TW9kZSgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9yb3V0ZXIuZXZlbnRzXHJcbiAgICAgIC5waXBlKGZpcnN0KChldmVudCk6IGV2ZW50IGlzIFJvdXRlc1JlY29nbml6ZWQgPT4gZXZlbnQgaW5zdGFuY2VvZiBSb3V0ZXNSZWNvZ25pemVkKSlcclxuICAgICAgLnN1YnNjcmliZSgoeyB1cmwgfSkgPT4ge1xyXG4gICAgICAgIC8vIGBsb2NhdGlvbi5wYXRobmFtZWAgYWx3YXlzIGVxdWFscyBtYW51YWxseSBlbnRlcmVkIFVSTCBpbiB0aGUgYWRkcmVzcyBiYXJcclxuICAgICAgICAvLyBlLmcuIGBsb2NhdGlvbi5wYXRobmFtZSA9PT0gJy9mb28nYCwgYnV0IHRoZSBgcm91dGVyYCBzdGF0ZSBoYXMgYmVlbiBpbml0aWFsaXplZFxyXG4gICAgICAgIC8vIHdpdGggYW5vdGhlciBVUkwgKGUuZy4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBOZ3hzU3RvcmFnZVBsdWdpbmApLCB0aHVzIHRoZVxyXG4gICAgICAgIC8vIGBSb3V0ZXJOYXZpZ2F0aW9uYCBhY3Rpb24gd2lsbCBiZSBkaXNwYXRjaGVkIGFuZCB0aGUgdXNlciB3aWxsIGJlIHJlZGlyZWN0ZWQgdG8gdGhlXHJcbiAgICAgICAgLy8gcHJldmlvdXNseSBzYXZlZCBVUkwuIFdlIHdhbnQgdG8gcHJldmVudCBzdWNoIGJlaGF2aW9yLCBzbyB3ZSBwZXJmb3JtIHRoaXMgY2hlY2tcclxuXHJcbiAgICAgICAgLy8gYHVybGAgaXMgYSByZWNvZ25pemVkIFVSTCBieSB0aGUgQW5ndWxhcidzIHJvdXRlciwgd2hpbGUgYGN1cnJlbnRVcmxgIGlzIGFuIGFjdHVhbCBVUkxcclxuICAgICAgICAvLyBlbnRlcmVkIGluIHRoZSBicm93c2VyJ3MgYWRkcmVzcyBiYXJcclxuICAgICAgICAvLyBgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnBhdGgoKWAgcmV0dXJucyBhIGNvbmNhdGVuYXRpb24gb2ZcclxuICAgICAgICAvLyBgUGxhdGZvcm1Mb2NhdGlvbi5wYXRobmFtZWAgYW5kIG5vcm1hbGl6ZWQgYFBsYXRmb3JtTG9jYXRpb24uc2VhcmNoYC5cclxuXHJcbiAgICAgICAgLy8gYExvY2F0aW9uLnByb3RvdHlwZS5ub3JtYWxpemVgIHN0cmlwcyBiYXNlIGhyZWYgZnJvbSB0aGUgVVJMLFxyXG4gICAgICAgIC8vIGlmIGBiYXNlSHJlZmAgKGRlY2xhcmVkIGluIGFuZ3VsYXIuanNvbikgZm9yIGV4YW1wbGUgaXMgYC9lbmBcclxuICAgICAgICAvLyBhbmQgdGhlIFVSTCBpcyBgL3Rlc3QjYW5jaG9yYCAtIHRoZW4gYF9sb2NhdGlvblN0cmF0ZWd5LnBhdGgodHJ1ZSlgIHdpbGwgcmV0dXJuIGAvZW4vdGVzdCNhbmNob3JgLFxyXG4gICAgICAgIC8vIGJ1dCBgL2VuL3Rlc3QjYW5jaG9yYCBpcyBub3Qga25vd24gdG8gdGhlIEFuZ3VsYXIncyByb3V0ZXIsIHNvIHdlIGhhdmUgdG8gc3RyaXAgYC9lbmBcclxuICAgICAgICAvLyBmcm9tIHRoZSBVUkxcclxuICAgICAgICBjb25zdCBjdXJyZW50VXJsID0gdGhpcy5fbG9jYXRpb24ubm9ybWFsaXplKHRoaXMuX2xvY2F0aW9uU3RyYXRlZ3kucGF0aCh0cnVlKSk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFVybFRyZWUgPSB0aGlzLl91cmxTZXJpYWxpemVyLnBhcnNlKGN1cnJlbnRVcmwpO1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2VyaWFsaXplIHRoZSBVUkwgYmVjYXVzZSBpbiB0aGF0IGV4YW1wbGUgYC90ZXN0Lz9yZWRpcmVjdD1odHRwczovL2dvb2dsZS5jb20vYFxyXG4gICAgICAgIC8vIEFuZ3VsYXIgd2lsbCByZWNvZ25pemUgaXQgYXMgYC90ZXN0P3JlZGlyZWN0PWh0dHBzOiUyRiUyRnd3dy5nb29nbGUuY29tJTJGYFxyXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gcnVuIHRoZSBgY3VycmVudFVybGAgdmlhIHRoZSBgVXJsU2VyaWFsaXplcmAgdGhhdCB3aWxsIGVuY29kZSBjaGFyYWN0ZXJzXHJcbiAgICAgICAgY29uc3QgY3VycmVudFNlcmlhbGl6ZWRVcmwgPSB0aGlzLl91cmxTZXJpYWxpemVyLnNlcmlhbGl6ZShjdXJyZW50VXJsVHJlZSk7XHJcblxyXG4gICAgICAgIC8vIElmIFVSTHMgZGlmZmVyIGZyb20gZWFjaCBvdGhlciAtIHdlJ3ZlIGdvdCB0byBwZXJmb3JtIGEgcmVkaXJlY3QgdG8gdGhlIG1hbnVhbGx5IGVudGVyZWQgVVJMXHJcbiAgICAgICAgLy8gaW4gdGhlIGFkZHJlc3MgYmFyLCBhcyBpdCBtdXN0IGhhdmUgYSBwcmlvcml0eVxyXG4gICAgICAgIGlmIChjdXJyZW50U2VyaWFsaXplZFVybCAhPT0gdXJsKSB7XHJcbiAgICAgICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGVCeVVybChjdXJyZW50VXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=